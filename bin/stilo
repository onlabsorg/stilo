#!/usr/bin/env node

const logger = require("js-logger");
logger.useDefaults();

const pathlib = require('path');
const fs = require('fs');

const {Package} = require("..");

const cmd = require("commander");


cmd.version(`v${require("../package.json").version}`, "-v --version");


cmd.command("init")
    .description("initialize the current directory as the root of an olojs document package")
    .action(async () => {
        try {
            logger.info(`@stilo: Initializing stilo package ...`);
            const package = await Package.create(process.cwd());
            logger.info("@stilo: Package successfully initialized.");

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("install <plugin>")
    .description("install a plugin")
    .action(async (packageId) => {
        logger.info(`@stilo: installing ${packageId}`);
        try {
            const package = Package.find(process.cwd());
            if (packageId[0] === '.') {
                packageId = pathlib.join(process.cwd(), packageId);
            }
            await package.install(packageId);
            logger.info(`@stilo: ${packageId} plugin installed`);

        } catch (error) {
            logger.error(error);
        }
    });


cmd.command("uninstall <plugin>")
    .description("uninstall a plugin")
    .action(async (packageId) => {
        logger.info(`@stilo: uninstalling ${packageId}`);
        try {
            const package = Package.find(process.cwd());
            await package.uninstall(packageId);
            logger.info(`@stilo: ${packageId} plugin uninstalled`);

        } catch (error) {
            logger.error(error);
        }
    });


cmd.command("read <path>")
    .description("fetch a document source and print it to the stdout")
    .action(async path => {
        try {
            const package = Package.find(process.cwd());
            const store = await loadStore(package);
            const fullPath = resolveDocumentPath(package, path);
            const source = await store.read(fullPath);
            console.log(source);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("render <path> [params...]")
    .description("render a document and print it to the stdout")
    .action(async (path, params) => {
        try {
            const package = Package.find(process.cwd());
            const store = await loadStore(package);
            const fullPath = resolveDocumentPath(package, path);
            const docId = `${fullPath}?${params.join('&')}`;
            const doc = await store.load(docId);
            const evaluate = doc.parse();
            const context = doc.createContext();
            const {text} = await evaluate(context);
            console.log(text);

        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("list [path]")
    .description("list the content of a directory")
    .action(async (path=".") => {
        try {
            const package = Package.find(process.cwd());
            const store = await loadStore(package);
            const dirPath = resolveDocumentPath(package, path);
            const items = (await store.list(dirPath)).filter(name => name && name[0] !== '.');
            console.log(`${items.length} items found in ${dirPath}:\n`);
            for (let item of items) console.log(`  ${item}`);
            console.log();
            
        } catch (error) {
            logger.error(error.message);
        }
    });


cmd.command("run <command-name> [params...]")
    .description("executes a sub-command")
    .action(async (commandName, params) => {
        const package = Package.find(process.cwd());
        const commands = package.require('./commands');
        const command = commands[commandName];
        if (command) {
            const store = await loadStore(package);
            const options = store.create(`/?${params.join('&')}`).query;
            await command(store, options);
        } else {
            logger.error(`Unknown command: ${commandName}`);
        }
    });


cmd.command("commands")
    .description("list the available sub-commands")
    .action(async (commandName, params) => {
        const package = Package.find(process.cwd());
        const commands = package.require('./commands');
        for (let commandName in commands) {
            console.log(commandName);
        }
    });


function resolveDocumentPath (package, path) {
    if (path[0] === '/' || path.match(/^([a-zA-Z][a-zA-Z0-9+.-]*):\/(.*)$/)) {
        return path;
    } else {
        const rootPath = package.resolvePath('..');
        const relativeCWD = pathlib.join('/', process.cwd().slice(rootPath.length));
        return pathlib.resolve(`/${relativeCWD}`, path);
    }
}

async function loadStore (package) {
    const Store = package.require('./store');
    const homePath = package.resolvePath('..');
    return await Store(homePath);
}


cmd.parse( process.argv );
